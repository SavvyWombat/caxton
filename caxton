#!/usr/bin/env php
<?php

require_once 'vendor/autoload.php';

use Illuminate\Contracts\Foundation\Application;
use Illuminate\Events\Dispatcher;
use Illuminate\Filesystem\Filesystem;
use Illuminate\Support\Facades\Blade;
use Illuminate\Support\Facades\Facade;
use Illuminate\Support\Facades\View;
use Illuminate\View\Compilers\BladeCompiler;
use Illuminate\View\Engines\CompilerEngine;
use Illuminate\View\Engines\EngineResolver;
use Illuminate\View\Factory;
use Illuminate\View\FileViewFinder;
use SavvyWombat\Caxton\App;
use SavvyWombat\Caxton\ContentFileFilter;

$_ENV['VERBOSE'] = in_array('-v', $argv) || in_array('--verbose', $argv);

$index = array_search('-e', $argv) ?: array_search('--env', $argv);
$_ENV['ENVIRONMENT'] = $argv[$index + 1] ?? 'dev';
$_ENV['WORKING_DIR'] = getcwd();

// prefer specific environment if available
$env = Dotenv\Dotenv::createImmutable(realpath($_ENV['WORKING_DIR']), '.env.' . $_ENV['ENVIRONMENT']);
$env->safeLoad();

// fill in any gaps from local .env
$dotenv = Dotenv\Dotenv::createImmutable(realpath($_ENV['WORKING_DIR']));
$dotenv->load();

// look for a caxton config
$_ENV['CONFIG'] = [];
if (file_exists(realpath($_ENV['WORKING_DIR'] . '/caxton.json'))) {
    $_ENV['CONFIG'] = json_decode(
            file_get_contents(realpath($_ENV['WORKING_DIR'] . '/caxton.json')),
            true
    );
}

$_ENV['BASE_URL'] = $_ENV['BASE_URL'] ?? "http://localhost";
$_ENV['CONTENT_PATH'] = $_ENV['WORKING_DIR'] . ($_ENV['CONTENT_DIR'] ?? '/content');
$_ENV['PUBLIC_PATH'] = $_ENV['WORKING_DIR'] . ($_ENV['PUBLIC_DIR'] ?? '/public');
$_ENV['CACHE_PATH'] = $_ENV['WORKING_DIR'] . '/build' . ($_ENV['CACHE_DIR'] ?? '/cache');
$_ENV['OUTPUT_PATH'] = $_ENV['WORKING_DIR'] . '/build' . ($_ENV['OUTPUT_DIR'] ?? '/' . $_ENV['ENVIRONMENT']);

// 0.   clean old build
if (! file_exists($_ENV['WORKING_DIR'] . '/build')) {
    mkdir($_ENV['WORKING_DIR'] . '/build', 0775);
}

if (file_exists($_ENV['OUTPUT_PATH'])) {
    $oldFiles = new RecursiveIteratorIterator(
        new RecursiveDirectoryIterator(
            $_ENV['OUTPUT_PATH'],
            RecursiveDirectoryIterator::SKIP_DOTS
        ),
        RecursiveIteratorIterator::CHILD_FIRST
    );

    foreach ($oldFiles as $oldFile) {
        $oldFile->isLink() || $oldFile->isFile()
            ? unlink($oldFile)
            : rmdir($oldFile);
    }
}

// 1.   copy stuff from public to content

// 1.1. scan public folder for structure
$publicFiles = new RecursiveIteratorIterator(
    new ContentFileFilter(
        new RecursiveDirectoryIterator(
            $_ENV['PUBLIC_PATH'],
            FilesystemIterator::SKIP_DOTS
        )
    ),
    RecursiveIteratorIterator::SELF_FIRST
);

// 1.2. copy files
foreach ($publicFiles as $publicFile) {
    $subpath = str_replace(
        $_ENV['PUBLIC_PATH'],
        '',
        $publicFile->getRealPath()
    );

    if (!file_exists($_ENV['OUTPUT_PATH'] . dirname($subpath))) {
        // directories need the 'execute/search' bit
        // permissions are subject to the umask value in the running environment
        mkdir($_ENV['OUTPUT_PATH'] . dirname($subpath), 0775, true);
    }

    if (!is_dir($publicFile->getRealPath())) {
        writeLn($subpath);
        copy($publicFile->getRealPath(), $_ENV['OUTPUT_PATH'] . $subpath);
    }
}

// 2.   build assets (styles and scripts)

// 3.   build content

// 3.1. scan content folder for structure
$contentFiles = new RecursiveIteratorIterator(
    new ContentFileFilter(
        new RecursiveDirectoryIterator(
            $_ENV['CONTENT_PATH'],
            FilesystemIterator::SKIP_DOTS
        )
    ),
    RecursiveIteratorIterator::SELF_FIRST
);

// 3.2. extract front matter - tags?

// 3.3. render content to output
$container = App::getInstance();

// we have to bind our app class to the interface
// as the blade compiler needs the `getNamespace()` method to guess Blade component FQCNs
$container->instance(Application::class, $container);

// Dependencies
$filesystem = new Filesystem;
$eventDispatcher = new Dispatcher($container);

// Create View Factory capable of rendering PHP and Blade templates
$viewResolver = new EngineResolver;
$bladeCompiler = new BladeCompiler($filesystem, $_ENV['CACHE_PATH']);

$viewResolver->register('blade', function () use ($bladeCompiler) {
    return new CompilerEngine($bladeCompiler);
});

$viewFinder = new FileViewFinder($filesystem, [$_ENV['CONTENT_PATH']]);
$viewFactory = new Factory($viewResolver, $viewFinder, $eventDispatcher);
$viewFactory->setContainer($container);
Facade::setFacadeApplication($container);
$container->instance(\Illuminate\Contracts\View\Factory::class, $viewFactory);
$container->alias(
    \Illuminate\Contracts\View\Factory::class,
    (new class extends View {
        public static function getFacadeAccessor()
        {
            return parent::getFacadeAccessor();
        }
    })::getFacadeAccessor()
);
$container->instance(BladeCompiler::class, $bladeCompiler);
$container->alias(
    BladeCompiler::class,
    (new class extends Blade {
        public static function getFacadeAccessor()
        {
            return parent::getFacadeAccessor();
        }
    })::getFacadeAccessor()
);

foreach ($contentFiles as $contentFile) {
    $subpath = str_replace(
        $_ENV['CONTENT_PATH'],
        '',
        $contentFile->getRealPath()
    );

    if (!file_exists($_ENV['OUTPUT_PATH'] . dirname($subpath))) {
        // directories need the 'execute/search' bit
        // permissions are subject to the umask value in the running environment
        mkdir($_ENV['OUTPUT_PATH'] . dirname($subpath), 0775, true);
    }

    if (str_ends_with($subpath, '.blade.php')) {
        $subpath = str_replace('.blade.php', '', $subpath);
        $output = $viewFactory->make(
            str_replace('/', '.', $subpath),
            [
                'page' => null,
                'url' => $_ENV['BASE_URL'] . (str_ends_with($subpath, 'index') ? substr($subpath, 0, -5) : $subpath),
            ]
        )->render();

        writeLn($_ENV['BASE_URL'] . (str_ends_with($subpath, 'index') ? substr($subpath, 0, -5) : $subpath));
        file_put_contents($_ENV['OUTPUT_PATH'] . $subpath . '.html', $output);
    } else if (!is_dir($contentFile->getRealPath())) {
        writeLn($subpath);
        copy($contentFile->getRealPath(), $_ENV['OUTPUT_PATH'] . $subpath);
    }
}

function writeLn(string $line, $force = false) {
    if ($force || $_ENV['VERBOSE']) {
        echo $line . "\n";
    }
}

