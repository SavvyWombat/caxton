#!/usr/bin/env php
<?php

require_once 'vendor/autoload.php';

use Illuminate\Contracts\Foundation\Application;
use Illuminate\Events\Dispatcher;
use Illuminate\Filesystem\Filesystem;
use Illuminate\Support\Facades\Blade;
use Illuminate\Support\Facades\Facade;
use Illuminate\Support\Facades\View;
use Illuminate\View\Compilers\BladeCompiler;
use Illuminate\View\Engines\CompilerEngine;
use Illuminate\View\Engines\EngineResolver;
use Illuminate\View\Factory;
use Illuminate\View\FileViewFinder;
use SavvyWombat\Caxton\App;
use SavvyWombat\Caxton\Config;
use SavvyWombat\Caxton\ConfigFile;
use SavvyWombat\Caxton\ContentFileFilter;

$config = [];
$config['verbose'] = in_array('-v', $argv) || in_array('--verbose', $argv);

$index = array_search('-e', $argv) ?: array_search('--env', $argv);
$config['environment'] = $argv[$index + 1] ?? 'dev';
$config['paths']['base'] = getcwd();

// prefer specific environment if available
$env = Dotenv\Dotenv::createImmutable(realpath($config['paths']['base']), '.env.' . $config['environment']);
$env->safeLoad();

// fill in any gaps from local .env
$dotenv = Dotenv\Dotenv::createImmutable(realpath($config['paths']['base']));
$dotenv->load();

$config['base_url'] = $_ENV['BASE_URL'] ?? "http://localhost";
$config['paths']['content'] = $config['paths']['base'] . ($_ENV['CONTENT_DIR'] ?? '/content');
$config['paths']['public'] = $config['paths']['base'] . ($_ENV['PUBLIC_DIR'] ?? '/public');
$config['paths']['cache'] = $config['paths']['base'] . '/build' . ($_ENV['CACHE_DIR'] ?? '/cache');
$config['paths']['output'] = $config['paths']['base'] . '/build' . ($_ENV['OUTPUT_DIR'] ?? '/' . $config['environment']);

$config = Config::instance(
    $config,
    ConfigFile::read($config['paths']['base'] . '/caxton.json', []),
    ConfigFile::read($config['paths']['base'] . '/caxton.' . $config['environment'] . '.json', []),
);

// 0.   clean old build
if (! file_exists($config::instance()->get('paths.base') . '/build')) {
    mkdir($config::instance()->get('paths.base') . '/build', 0775);
}

if (file_exists(Config::instance()->get('paths.output'))) {
    $oldFiles = new RecursiveIteratorIterator(
        new RecursiveDirectoryIterator(
            Config::instance()->get('paths.output'),
            RecursiveDirectoryIterator::SKIP_DOTS
        ),
        RecursiveIteratorIterator::CHILD_FIRST
    );

    foreach ($oldFiles as $oldFile) {
        $oldFile->isLink() || $oldFile->isFile()
            ? unlink($oldFile)
            : rmdir($oldFile);
    }
}

// 1.   copy stuff from public to content

// 1.1. scan public folder for structure
$publicFiles = new RecursiveIteratorIterator(
    new ContentFileFilter(
        new RecursiveDirectoryIterator(
            Config::instance()->get('paths.public'),
            FilesystemIterator::SKIP_DOTS
        )
    ),
    RecursiveIteratorIterator::SELF_FIRST
);

// 1.2. copy files
foreach ($publicFiles as $publicFile) {
    $subpath = str_replace(
        Config::instance()->get('paths.public'),
        '',
        $publicFile->getRealPath()
    );

    if (!file_exists(Config::instance()->get('paths.output') . dirname($subpath))) {
        // directories need the 'execute/search' bit
        // permissions are subject to the umask value in the running environment
        mkdir(Config::instance()->get('paths.output') . dirname($subpath), 0775, true);
    }

    if (!is_dir($publicFile->getRealPath())) {
        writeLn($subpath);
        copy($publicFile->getRealPath(), Config::instance()->get('paths.output') . $subpath);
    }
}

// 2.   build assets (styles and scripts)

// 3.   build content

// 3.1. scan content folder for structure
$contentFiles = new RecursiveIteratorIterator(
    new ContentFileFilter(
        new RecursiveDirectoryIterator(
            Config::instance()->get('paths.content'),
            FilesystemIterator::SKIP_DOTS
        )
    ),
    RecursiveIteratorIterator::SELF_FIRST
);

// 3.2. extract front matter - tags?

// 3.3. render content to output
$container = App::getInstance();

// we have to bind our app class to the interface
// as the blade compiler needs the `getNamespace()` method to guess Blade component FQCNs
$container->instance(Application::class, $container);

// Dependencies
$filesystem = new Filesystem;
$eventDispatcher = new Dispatcher($container);

// Create View Factory capable of rendering PHP and Blade templates
$viewResolver = new EngineResolver;
$bladeCompiler = new BladeCompiler($filesystem, Config::instance()->get('paths.cache'));

$viewResolver->register('blade', function () use ($bladeCompiler) {
    return new CompilerEngine($bladeCompiler);
});

$viewFinder = new FileViewFinder($filesystem, [Config::instance()->get('paths.content')]);
$viewFactory = new Factory($viewResolver, $viewFinder, $eventDispatcher);
$viewFactory->setContainer($container);
Facade::setFacadeApplication($container);
$container->instance(\Illuminate\Contracts\View\Factory::class, $viewFactory);
$container->alias(
    \Illuminate\Contracts\View\Factory::class,
    (new class extends View {
        public static function getFacadeAccessor()
        {
            return parent::getFacadeAccessor();
        }
    })::getFacadeAccessor()
);
$container->instance(BladeCompiler::class, $bladeCompiler);
$container->alias(
    BladeCompiler::class,
    (new class extends Blade {
        public static function getFacadeAccessor()
        {
            return parent::getFacadeAccessor();
        }
    })::getFacadeAccessor()
);

foreach ($contentFiles as $contentFile) {
    $subpath = str_replace(
        Config::instance()->get('paths.content'),
        '',
        $contentFile->getRealPath()
    );

    if (!file_exists(Config::instance()->get('paths.output') . dirname($subpath))) {
        // directories need the 'execute/search' bit
        // permissions are subject to the umask value in the running environment
        mkdir(Config::instance()->get('paths.output') . dirname($subpath), 0775, true);
    }

    if (str_ends_with($subpath, '.blade.php')) {
        $subpath = str_replace('.blade.php', '', $subpath);
        $output = $viewFactory->make(
            str_replace('/', '.', $subpath),
            [
                'page' => null,
                'url' => Config::instance()->get('base_url') . (str_ends_with($subpath, 'index') ? substr($subpath, 0, -5) : $subpath),
            ]
        )->render();

        writeLn(Config::instance()->get('base_url') . (str_ends_with($subpath, 'index') ? substr($subpath, 0, -5) : $subpath));
        file_put_contents(Config::instance()->get('paths.output') . $subpath . '.html', $output);
    } else if (!is_dir($contentFile->getRealPath())) {
        writeLn($subpath);
        copy($contentFile->getRealPath(), Config::instance()->get('paths.output') . $subpath);
    }
}

function writeLn(string $line, $force = false) {
    if ($force || Config::instance()->get('verbose')) {
        echo $line . "\n";
    }
}

